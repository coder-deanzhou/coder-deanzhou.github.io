<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单例模式</title>
      <link href="/2024/08/04/5.ji-ben-gong/3.she-ji-mo-shi/1.chuang-jian-xing/dan-li-mo-shi/"/>
      <url>/2024/08/04/5.ji-ben-gong/3.she-ji-mo-shi/1.chuang-jian-xing/dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>单例模式是最常用的构造型模式.基本上在任何一个项目中都会大量的使用这种模式，掌握其使用方式是软件工程化的必备技能</p><h2 id="java-单例模式"><a href="#java-单例模式" class="headerlink" title="java 单例模式"></a>java 单例模式</h2><p>定义;<br>    确保某一个类只有一个实例，并且自行实例化并且向整个系统提供这个实例<br>实现单例模式有几个比较重要的关键点：</p><ol><li>构造的函数一般不对外进行开放，使用private私有属性</li><li>通过一个静态方法或者枚举返回单例对象</li><li>确保单例类的对象有且只有一个，尤其是在多线程下，一定要保持线程的安全</li><li><font color='orange'>确保单例类对象子反序列化的时候不会重新构建对象</font></li></ol><p>单例模式分类：</p><ul><li>饿汉式单例模式</li><li>懒汉式单例模式</li><li>双重检查锁实现单例</li><li>静态内部类来实现单例模式</li><li>使用枚举类型来实现单例</li><li>使用容器的形式来实现单例子模式</li></ul><h3 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><p>  在静态代码块中去new对象， 但是线程不安全，在不使用的时候，其实对象也已经实例化了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.zzf.single;</span><br><span class="line"></span><br><span class="line">import java.io.ObjectStreamException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 饿汉式单例模式</span><br><span class="line"> * 在静态代码块中去new对象，</span><br><span class="line"> * 但是线程不安全，在不使用的时候，其实对象也已经实例化了</span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SingleTonOne &#123;</span><br><span class="line"></span><br><span class="line">private static final SingleTonOne singleTonOne = new SingleTonOne();</span><br><span class="line"></span><br><span class="line">private SingleTonOne()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static SingleTonOne getInstance()&#123;</span><br><span class="line">return singleTonOne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void doSomething()&#123;</span><br><span class="line">System.out.println(&quot;this is SingleTonOne&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 防止单例对象在序列化后，再次反序列化后生成不同的对象</span><br><span class="line"> * @return</span><br><span class="line"> * @throws ObjectStreamException</span><br><span class="line"> */</span><br><span class="line">private Object readResolve() throws ObjectStreamException&#123;</span><br><span class="line">return singleTonOne;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h3><p> 优点：在实例化的时候去new对象，线程安全<br> 缺点：每一次使用的时候都需要进行同步一次，这样会过多的消耗资源</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.zzf.single;</span><br><span class="line"></span><br><span class="line">import java.io.ObjectStreamException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 懒汉式单例模式</span><br><span class="line"> * 优点：在实例化的时候去new对象，线程安全</span><br><span class="line"> * 缺点：每一次使用的时候都需要进行同步一次，这样会过多的消耗资源</span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SingleTonTwo &#123;</span><br><span class="line">private static SingleTonTwo singleTonTwo;</span><br><span class="line"></span><br><span class="line">private SingleTonTwo()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static synchronized SingleTonTwo getInstance()&#123;</span><br><span class="line">if(singleTonTwo == null)&#123;</span><br><span class="line">singleTonTwo = new SingleTonTwo();</span><br><span class="line">&#125;</span><br><span class="line">return singleTonTwo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void doSomething()&#123;</span><br><span class="line">System.out.println(&quot;this is SingleTonTwo&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 防止单例对象在序列化后，再次反序列化后生成不同的对象</span><br><span class="line"> * @return</span><br><span class="line"> * @throws ObjectStreamException</span><br><span class="line"> */</span><br><span class="line">private Object readResolve() throws ObjectStreamException&#123;</span><br><span class="line">return singleTonTwo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重检查锁实现单例"><a href="#双重检查锁实现单例" class="headerlink" title="双重检查锁实现单例"></a>双重检查锁实现单例</h3><p> 优点：在需要的时候才去实例化，而且能保证线程的安全行，而且单例模式在初始化后，就不会在进行同步，也不会过多的消耗资源<br> 缺点：第一次在加载的时候会加载稍微慢一点，双重检查锁失效可能会出现单例实现有问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.zzf.single;</span><br><span class="line"></span><br><span class="line">import java.io.ObjectStreamException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 双重检查锁实现单例</span><br><span class="line"> * 有点：在需要的时候才去实例化，而且能保证线程的安全行，而且单例模式在初始化后，就不会在进行同步，也不会过多的消耗资源</span><br><span class="line"> * 缺点：第一次在加载的时候会加载稍微慢一点</span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SingleTonThree &#123;</span><br><span class="line">private static SingleTonThree sInstance = null;</span><br><span class="line">//private static volatile  SingleTonThree sInstance = null; //从主内存中读取，会影响性能</span><br><span class="line"></span><br><span class="line">private SingleTonThree()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static SingleTonThree getInstance()&#123;</span><br><span class="line">if(sInstance == null)&#123;</span><br><span class="line">synchronized (SingleTonThree.class) &#123;</span><br><span class="line">if(sInstance == null)&#123;</span><br><span class="line">sInstance = new SingleTonThree();</span><br><span class="line">&#125;</span><br><span class="line">return sInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return sInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void doSomething()&#123;</span><br><span class="line">System.out.println(&quot;this is SingleTonThree&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 防止单例对象在序列化后，再次反序列化后生成不同的对象</span><br><span class="line"> * @return</span><br><span class="line"> * @throws ObjectStreamException</span><br><span class="line"> */</span><br><span class="line">private Object readResolve() throws ObjectStreamException&#123;</span><br><span class="line">return sInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类来实现单例模式"><a href="#静态内部类来实现单例模式" class="headerlink" title="静态内部类来实现单例模式"></a>静态内部类来实现单例模式</h3><p>  由于双重检查锁在高并发或者因为内存模型的原因，有时候偶尔会失效，所以推荐使用静态内部类来实现单例模式<br> 第一次加载的时候不会初始化SingleTonFour，只有第一次调用getInstance的时候才会去创建对象，<br> 既保证了线程安全性么也保证对象唯一性，同时延迟了单例的实例化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.zzf.single;</span><br><span class="line"></span><br><span class="line">import java.io.ObjectStreamException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 静态内部类来实现单例莫斯</span><br><span class="line"> * 由于双重检查锁在高并发或者因为内存模型的原因，有时候偶尔会失效，所以推荐使用静态内部类来实现单例模式</span><br><span class="line"> * 第一次加载的时候不会初始化SingleTonFour，只有第一次调用getInstance的时候才会去创建对象，</span><br><span class="line"> * 既保证了线程安全性么也保证对象唯一性，同事延迟了单利的实例化</span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SingleTonFour &#123;</span><br><span class="line">private SingleTonFour()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static SingleTonFour getInstance()&#123;</span><br><span class="line">return SingleTonFourHolder.singleTonFour;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class SingleTonFourHolder&#123;</span><br><span class="line">private static final SingleTonFour singleTonFour = new SingleTonFour();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void doSomething()&#123;</span><br><span class="line">System.out.println(&quot;this is SingleTonFour&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 防止单例对象在序列化后，再次反序列化后生成不同的对象</span><br><span class="line"> * @return</span><br><span class="line"> * @throws ObjectStreamException</span><br><span class="line"> */</span><br><span class="line">private Object readResolve() throws ObjectStreamException&#123;</span><br><span class="line">return SingleTonFourHolder.singleTonFour;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用枚举类型来实现单例"><a href="#使用枚举类型来实现单例" class="headerlink" title="使用枚举类型来实现单例"></a>使用枚举类型来实现单例</h3><p>好处：枚举在java中就和普通的类型是一样的，不仅能够有字段，还可以有自己的方法，最主要的就是枚举类型实例的创建默认是线程安全的，在任何一种情况下他都只会有一个实例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.zzf.single;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用枚举类型来实现单例</span><br><span class="line"> * 好处：枚举在java中就和普通的类型是一样的，不仅能够有字段，还可以有自己的方法，最主要的就是枚举类型实例的创建默认是线程安全的，在任何一种情况下他都只会有一个实例</span><br><span class="line"> * </span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public enum SingleTonEnum &#123;</span><br><span class="line">INSTANCE;</span><br><span class="line">public void doSomething()&#123;</span><br><span class="line">System.out.println(&quot;this is SingleTonEnum!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用容器的形式来实现单例子模式"><a href="#使用容器的形式来实现单例子模式" class="headerlink" title="使用容器的形式来实现单例子模式"></a>使用容器的形式来实现单例子模式</h3><p>将多个单例类型全部注入到一个管理类中进行统一管理，根据需求来选择</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.zzf.single;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用容器的形式来实现单例子模式</span><br><span class="line"> * 将多个单例类型全部注入到一个管理类中进行统一管理，根据需求来选择</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class SingleTonManager &#123;</span><br><span class="line">private static Map&lt;String,Object&gt; objectMap = new HashMap();</span><br><span class="line"></span><br><span class="line">private SingleTonManager()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static  void registerSingleServer(String key,Object instance)&#123;</span><br><span class="line">if(!objectMap.containsKey(key))&#123;</span><br><span class="line">objectMap.put(key, instance);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Object getSingleService(String key)&#123;</span><br><span class="line">return objectMap.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MainTest.java中的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.zzf;</span><br><span class="line"></span><br><span class="line">import com.example.zzf.single.SingleTonEnum;</span><br><span class="line">import com.example.zzf.single.SingleTonFour;</span><br><span class="line">import com.example.zzf.single.SingleTonManager;</span><br><span class="line">import com.example.zzf.single.SingleTonOne;</span><br><span class="line">import com.example.zzf.single.SingleTonThree;</span><br><span class="line">import com.example.zzf.single.SingleTonTwo;</span><br><span class="line"></span><br><span class="line">public class MainTest &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param args</span><br><span class="line"> */</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">SingleTonOne singleTonOne = SingleTonOne.getInstance();</span><br><span class="line">singleTonOne.doSomething();</span><br><span class="line">SingleTonManager.registerSingleServer(&quot;SingleTonOne&quot;, singleTonOne);</span><br><span class="line"></span><br><span class="line">SingleTonTwo singleTonTwo = SingleTonTwo.getInstance();</span><br><span class="line">singleTonTwo.doSomething();</span><br><span class="line">SingleTonManager.registerSingleServer(&quot;SingleTonTwo&quot;, singleTonTwo);</span><br><span class="line"></span><br><span class="line">SingleTonThree singleTonThree = SingleTonThree.getInstance();</span><br><span class="line">singleTonThree.doSomething();</span><br><span class="line">SingleTonManager.registerSingleServer(&quot;SingleTonThree&quot;, singleTonThree);</span><br><span class="line"></span><br><span class="line">SingleTonFour singleTonFour = SingleTonFour.getInstance();</span><br><span class="line">singleTonFour.doSomething();</span><br><span class="line">SingleTonManager.registerSingleServer(&quot;SingleTonFour&quot;, singleTonFour);</span><br><span class="line"></span><br><span class="line">SingleTonEnum singleEnum = SingleTonEnum.INSTANCE;</span><br><span class="line">singleEnum.doSomething();</span><br><span class="line">SingleTonManager.registerSingleServer(&quot;SingleTonEnum&quot;, singleEnum);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;===========================================&quot;);</span><br><span class="line">singleTonOne = (SingleTonOne) (SingleTonManager.getSingleService(&quot;SingleTonOne&quot;));</span><br><span class="line">singleTonTwo = (SingleTonTwo) SingleTonManager.getSingleService(&quot;SingleTonTwo&quot;);</span><br><span class="line">singleTonThree = (SingleTonThree) SingleTonManager.getSingleService(&quot;SingleTonThree&quot;);</span><br><span class="line">singleTonFour = (SingleTonFour) SingleTonManager.getSingleService(&quot;SingleTonFour&quot;);</span><br><span class="line">singleEnum =(SingleTonEnum) SingleTonManager.getSingleService(&quot;SingleTonEnum&quot;);</span><br><span class="line">singleTonOne.doSomething();</span><br><span class="line">singleTonTwo.doSomething();</span><br><span class="line">singleTonThree.doSomething();</span><br><span class="line">singleTonFour.doSomething();</span><br><span class="line">singleEnum.doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些都是一些很简单的理解和总结，希望这些能够帮助到大家：<br>源码下载地址：<a href="http://download.csdn.net/detail/qq_29924041/9731392">源代码下载</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2024/08/04/5.ji-ben-gong/3.she-ji-mo-shi/1.chuang-jian-xing/yuan-xing-mo-shi/"/>
      <url>/2024/08/04/5.ji-ben-gong/3.she-ji-mo-shi/1.chuang-jian-xing/yuan-xing-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>原型模式是非常简单的，原型类中只有clone一个方法，而在java中提供了Cloneable这个接口来标识对象的可拷贝特性</p><h1 id="细说原型模式Prototype-Pattern"><a href="#细说原型模式Prototype-Pattern" class="headerlink" title="细说原型模式Prototype Pattern"></a>细说原型模式Prototype Pattern</h1><blockquote><p>作者：deanzhou<br>csdn 博客地址：<a href="http://blog.csdn.net/qq_29924041">http://blog.csdn.net/qq_29924041</a><br>github 博客地址：<a href="https://coder-deanzhou.github.io/">https://coder-deanzhou.github.io/</a></p></blockquote><h2 id="细说原型模式"><a href="#细说原型模式" class="headerlink" title="细说原型模式"></a>细说原型模式</h2><p>原型模式这个模式的简单程度是仅次于单例模式和迭代器模式，非常简单，但是要使<br>用好这个模式还有很多注意事项。原型，顾名思义，也就是本来的模型只有一个，类似电子工业生产中的模具，有了这个模具之后，后面所有的产品都可以由这个模具生产出来，但是这个模具生产出来后，可以完全一样，也可以在生产的产品后再修改出一部分差异化的东西。这就是原型模式。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>原型模式</strong>：用原型实例指定创建对象的种类，通过拷贝这些原型来创建新的对象。<br>其实也就是使用java的拷贝原理，在原型的基础之上创建新的对象而已。</p><h3 id="UML模型"><a href="#UML模型" class="headerlink" title="UML模型"></a>UML模型</h3><p><img src="/images/design_pattern/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8Fuml.png" alt="原型模式uml"><br>从上述的UML图中就可以看到，原型模式是非常简单的，原型类中只有clone一个方法，而在java中提供了Cloneable这个接口来标识对象的可拷贝特性。这个接口其实只是一个标记作用，在JVM中通过这个标记来识别出这个对象具有可拷贝的特性。</p><h4 id="基于UML的代码"><a href="#基于UML的代码" class="headerlink" title="基于UML的代码"></a>基于UML的代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package src.com.zzf.designpattern.prototypepattern.demo4;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 原型对象，实现Cloneable接口，重写clone方法</span><br><span class="line"> * </span><br><span class="line"> * @author zhouzhangfei</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class PrototypeClass implements Cloneable &#123;</span><br><span class="line">  public String name = &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">  // 重写clone方法</span><br><span class="line">  @Override</span><br><span class="line">  protected PrototypeClass clone() &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">    PrototypeClass prototypeClass = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      prototypeClass = (PrototypeClass) super.clone();</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">      // TODO Auto-generated catch block</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return prototypeClass;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package src.com.zzf.designpattern.prototypepattern.demo4;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 测试代码，通过拷贝方法，创建出了两个不同的对象</span><br><span class="line"> * </span><br><span class="line"> * @author zhouzhangfei</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Test &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    // 原型模式创建原始对象</span><br><span class="line">    PrototypeClass prototypeClass = new PrototypeClass();</span><br><span class="line">    System.out.println(prototypeClass.toString() + &quot;\t&quot; + prototypeClass.name);</span><br><span class="line">    // 通过克隆拷贝方法，创建出一个新的对象</span><br><span class="line">    PrototypeClass prototypeClass2 = prototypeClass.clone();</span><br><span class="line">    System.out.println(prototypeClass2.toString() + &quot;\t&quot; + prototypeClass2.name);</span><br><span class="line"></span><br><span class="line">    // 从上面可以看出，基本数据类型的拷贝是随着对象一起被克隆出去的，即两个对象的基本数据类型值是一致的</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>在之前所有关于设计模式的博客中都讲到了场景，同样，原型模式在实际的应用过程中也有非常多的场景。</p><h4 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h4><p>设计模式之禅中举了一个群发邮件的案例，定义一个邮件的模板类，通过改变邮件的收件者和内容，然后修改邮件的发送。这个在实际开发过程中是有很广泛的应用的。如果通过new的方式，会造成大量的性能浪费，而使用原型模式，通过内存已有的对象，把对象拷贝一份，产生一个新的对象，和原有对象一样，然后再修改细节的数据。有助于提高性能</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">package src.com.zzf.designpattern.prototypepattern.demo1;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 广告信的模板</span><br><span class="line"> * </span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AdvTemplate &#123;</span><br><span class="line">  private String advSubject = &quot;XX银行信用卡抽奖活动&quot;;</span><br><span class="line">  private String advContext = &quot;国庆抽奖活动:只要刷卡就送你一百万!...&quot;;</span><br><span class="line"></span><br><span class="line">  public String getAdvSubject() &#123;</span><br><span class="line">    return advSubject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setAdvSubject(String advSubject) &#123;</span><br><span class="line">    this.advSubject = advSubject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getAdvContext() &#123;</span><br><span class="line">    return advContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setAdvContext(String advContext) &#123;</span><br><span class="line">    this.advContext = advContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">package src.com.zzf.designpattern.prototypepattern.demo1;</span><br><span class="line"></span><br><span class="line">public class Mail implements Cloneable &#123;</span><br><span class="line">  // 收件人</span><br><span class="line">  String receiver;</span><br><span class="line">  // 邮件名称</span><br><span class="line">  String subject;</span><br><span class="line">  // 称谓</span><br><span class="line">  String appellation;</span><br><span class="line">  // 邮件内容</span><br><span class="line">  String context;</span><br><span class="line">  // 邮件的尾部</span><br><span class="line">  String tail;</span><br><span class="line"></span><br><span class="line">  public Mail(AdvTemplate mAdvTemplate) &#123;</span><br><span class="line">    this.context = mAdvTemplate.getAdvContext();</span><br><span class="line">    this.subject = mAdvTemplate.getAdvSubject();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getReceiver() &#123;</span><br><span class="line">    return receiver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setReceiver(String receiver) &#123;</span><br><span class="line">    this.receiver = receiver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getSubject() &#123;</span><br><span class="line">    return subject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setSubject(String subject) &#123;</span><br><span class="line">    this.subject = subject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getAppellation() &#123;</span><br><span class="line">    return appellation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setAppellation(String appellation) &#123;</span><br><span class="line">    this.appellation = appellation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getContext() &#123;</span><br><span class="line">    return context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setContext(String context) &#123;</span><br><span class="line">    this.context = context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getTail() &#123;</span><br><span class="line">    return tail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setTail(String tail) &#123;</span><br><span class="line">    this.tail = tail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected Mail clone() &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">    Mail mail = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      mail = (Mail) super.clone();</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">      // TODO Auto-generated catch block</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return mail;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">package src.com.zzf.designpattern.prototypepattern.demo1;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一是类初始化需要消化非常多的资源，这个资源包括数据、硬件资源</span><br><span class="line"> * 等；二是通过new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式；</span><br><span class="line"> * 三是一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对</span><br><span class="line"> * 象供调用者使用。在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone</span><br><span class="line"> * 的方法创建一个对象，然后由工厂方法提供给调用者。</span><br><span class="line"> * </span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line">  // 发送账单的数量，这个值是从数据库中获得</span><br><span class="line">  private static int MAX_COUNT = 6;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    // 模拟发送邮件</span><br><span class="line">    int i = 0;</span><br><span class="line">    // 把模板定义出来，这个是从数据库中获得</span><br><span class="line">    Mail mail = new Mail(new AdvTemplate());</span><br><span class="line">    mail.setTail(&quot;XX银行版权所有&quot;);</span><br><span class="line"></span><br><span class="line">    while (i &lt; MAX_COUNT) &#123;</span><br><span class="line">      // 以下是每封邮件不同的地方</span><br><span class="line">      Mail mailclone = mail.clone();</span><br><span class="line">      mailclone.setAppellation(getRandString(5) + &quot; 先生（女士）&quot;);</span><br><span class="line">      mailclone.setReceiver(getRandString(5) + &quot;@&quot; + getRandString(8) + &quot;.com&quot;);</span><br><span class="line">      // 然后发送邮件</span><br><span class="line">      sendMail(mailclone);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获得指定长度的随机字符串</span><br><span class="line">  public static String getRandString(int maxLength) &#123;</span><br><span class="line">    String source = &quot;abcdefghijklmnopqrskuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;</span><br><span class="line">    StringBuffer sb = new StringBuffer();</span><br><span class="line">    Random rand = new Random();</span><br><span class="line">    for (int i = 0; i &lt; maxLength; i++) &#123;</span><br><span class="line">      sb.append(source.charAt(rand.nextInt(source.length())));</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 发送邮件</span><br><span class="line">  public static void sendMail(Mail mail) &#123;</span><br><span class="line">    System.out.println(&quot;标题:&quot; + mail.getSubject() + &quot;\t收件人:&quot; + mail.getReceiver() + &quot;\t....发送成功！&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>对象拷贝时，类的构造函数是不会被执行的</p><h3 id="基于原型模式的深拷贝与浅拷贝"><a href="#基于原型模式的深拷贝与浅拷贝" class="headerlink" title="基于原型模式的深拷贝与浅拷贝"></a>基于原型模式的深拷贝与浅拷贝</h3><p>既然原型模式是通过拷贝的形式来进行的，那也就有必要分析一下什么叫做浅拷贝，什么叫深拷贝</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝（Shallow Copy）：①对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。②<strong>对于数据类型是引用数据类型的成员变量，****比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象</strong>。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。<br>如下描述代码所示：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">package src.com.zzf.designpattern.prototypepattern.demo2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 浅拷贝对象，</span><br><span class="line"> * </span><br><span class="line"> * @author zhouzhangfei</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Thing implements Cloneable &#123;</span><br><span class="line">  // 基本数据类型，int,String,long会直接拷贝一份过去</span><br><span class="line">  public String nameString = &quot;12345&quot;;</span><br><span class="line">  public String string = new String(&quot;9999999&quot;);</span><br><span class="line">  // 数组对象不会直接拷贝，而是会将其地址拷贝一份过去，导致两个对象会访问同一块内存区域</span><br><span class="line">  public int[] array = new int[] &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  public Thing() &#123;</span><br><span class="line">    System.out.println(&quot;构造函数被执行了&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected Thing clone() throws CloneNotSupportedException &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">    Thing mThing = null;</span><br><span class="line">    mThing = (Thing) super.clone();</span><br><span class="line">    return mThing;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">package src.com.zzf.designpattern.prototypepattern.demo2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 浅拷贝</span><br><span class="line"> * </span><br><span class="line"> * @author Administrator</span><br><span class="line"> *         内部的数组和引用对象不拷贝，其他的原始类型比如int,long,String(Java 就希望你把String</span><br><span class="line"> *         认为是基本类型，String 是没有clone 方法的)等都会被拷贝的。</span><br><span class="line"> */</span><br><span class="line">public class Test &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Thing mThing = new Thing();</span><br><span class="line">    System.err.println(mThing.nameString);</span><br><span class="line">    System.out.println(mThing.array);</span><br><span class="line">    try &#123;</span><br><span class="line">      Thing cloneThing = mThing.clone();</span><br><span class="line">      cloneThing.nameString = &quot;445567&quot;;</span><br><span class="line">      System.out.println(cloneThing.nameString);</span><br><span class="line">      System.out.println(cloneThing.string);</span><br><span class="line">      System.out.println(cloneThing.array);</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">      // TODO Auto-generated catch block</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>运行结果为：构造函数被执行了12345[I@7852e9224455679999999[I@7852e922</code></pre><p><strong>从结果中就可以看到。对于String,new String等数据类型结构，是直接在新的对象中拷贝了一份，而对于数组对象来说，则是把原型对象中的数组的地址拷贝了一份给新的对象，这就会导致两个数组对象会同时去访问同一块内存地址。这就是导致一种叫做脏数据的现象</strong></p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝（Deep Copy）：对原型对象的所有数据结构都进行了拷贝。也就是对原型对象中的引用数据类型，集合，数组，等都在新的拷贝对象中开辟了一个新的空间。<br>如下案例所示：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">package src.com.zzf.designpattern.prototypepattern.demo3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">/**</span><br><span class="line"> * Clone 与final 两对冤家</span><br><span class="line"> * 删除掉final 关键字，这是最便捷最安全最快速的方式，你要使用clone 方法就在类</span><br><span class="line">的成员变量上不要增加final 关键字</span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Thing implements Cloneable&#123;</span><br><span class="line">private ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();</span><br><span class="line">public int [] array = new int[]&#123;&#125;;</span><br><span class="line">@Override</span><br><span class="line">protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">  // TODO Auto-generated method stub</span><br><span class="line">  Thing thing = null;</span><br><span class="line">  thing = (Thing) super.clone();</span><br><span class="line">  thing.arrayList = (ArrayList&lt;String&gt;) this.arrayList.clone();</span><br><span class="line">  this.array = this.array.clone();</span><br><span class="line">  return thing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setValue(String obj) &#123;</span><br><span class="line">  this.arrayList.add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayList&lt;String&gt; getValue() &#123;</span><br><span class="line">  return arrayList;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">package src.com.zzf.designpattern.prototypepattern.demo3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line"> </span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">  //产生一个对象</span><br><span class="line">  Thing thing = new Thing();</span><br><span class="line">  //设置一个值</span><br><span class="line">  thing.setValue(&quot;张三&quot;);</span><br><span class="line">  </span><br><span class="line">  //拷贝一个对象</span><br><span class="line">  Thing cloneThing = null;</span><br><span class="line">  try &#123;</span><br><span class="line">   cloneThing = (Thing) thing.clone();</span><br><span class="line">  &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">   // TODO Auto-generated catch block</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  cloneThing.setValue(&quot;李四&quot;);</span><br><span class="line">  System.out.println(thing.array);</span><br><span class="line">  System.out.println(thing.getValue());</span><br><span class="line">  System.out.println(cloneThing.getValue());</span><br><span class="line">  System.out.println(cloneThing.array);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>执行结果为:[I@7852e922[张三][张三, 李四][I@4e25154f</code></pre><p>从上面结果中可以看到。数组对象地址发生了改变，也就是数组对象是重新开辟了一块内存区域，而集合对象也发生了改变，拷贝对象中包含了原型对象中的元素，但是拷贝对象在修改完自己内部的集合的时候，并不会引起原型对象集合内容的改变，这就是深度拷贝，拷贝的不仅仅是基本数据类型，会将引用数据类型的地址在新的对象中重新开辟一份出来</p><h4 id="原型模式clone与final冤家路窄"><a href="#原型模式clone与final冤家路窄" class="headerlink" title="原型模式clone与final冤家路窄"></a>原型模式clone与final冤家路窄</h4><p>final关键字我们都知道是不能改变的对吧，而clone是为了拷贝而存在的，clone对象的属性是随时都可以发生改变的，这也就造成了鱼与熊掌不可兼得的问题。<br><strong>解决方式：</strong><br>删除掉final 关键字，这是最便捷最安全最快速的方式，你要使用clone 方法就在类<br>的成员变量上不要增加final 关键字</p><h3 id="原型模式应用和注意事项"><a href="#原型模式应用和注意事项" class="headerlink" title="原型模式应用和注意事项"></a>原型模式应用和注意事项</h3><p>首先说优点吧：<br>1：原型模式是在内存的二进制流中进行的拷贝动作，。所以它会比new对象来的更快一些，也就是性能上会优化很多，尤其是在一个循环体内部产生大量对象的时候，这个时候非常推荐使用原型模式<br>2：原型模式在拷贝的时候构造函数是不会去执行的。</p><p>场景：<br>当一个类在初始化的时候比较消耗资源的时候，这个时候原型模式是一个好的选择<br>当在循环体中大量创建一个对象的时候，这个时候原型模式也是一个极佳的选择</p><p>注意：<br><strong>浅拷贝和深拷贝的区别..不要在拷贝的时候，犯错</strong></p><hr><br><p><font size="4"><a href="https://coder-deanzhou.github.io/" >欢迎继续访问，我的博客</a></font></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2024/08/04/5.ji-ben-gong/3.she-ji-mo-shi/1.chuang-jian-xing/jian-zao-zhe-mo-shi/"/>
      <url>/2024/08/04/5.ji-ben-gong/3.she-ji-mo-shi/1.chuang-jian-xing/jian-zao-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Logcat 系统讲解</title>
      <link href="/2024/07/28/1.android/2.android-xi-tong/1.android-xi-tong-ri-zhi/android-logcat-xi-tong-jiang-jie/"/>
      <url>/2024/07/28/1.android/2.android-xi-tong/1.android-xi-tong-ri-zhi/android-logcat-xi-tong-jiang-jie/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> android 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android系统日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/07/28/hello-world/"/>
      <url>/2024/07/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
